#include "Config.h"
#include "Font.h"
#include "MT12232D.h"

///////////////////////////////////////////////////////////////////////////////
// Библиотека для поддержки индикатора МЭЛТ MT-12232D на базе контроллера
// КБ145ВГ4 (ОАО АНГСТРЕМ), который является аналогом контроллера SED1520DOA
// (SEIKO EPSON). В индикаторе использованы 2 контроллера КБ145ВГ4.
// Индикатор подключается к Arduino Nano по параллельному интерфейсу.
///////////////////////////////////////////////////////////////////////////////

/*
============================================================
Подключение индикатора МЭЛТ MT-12232D-2YLG к Arduino Nano
============================================================
MT-12232D-2YLG	Arduino Nano	Название сигнала
------------------------------------------------------------
01 (DB4)		D4  (PD4)		Шина данных 4
02 (DB5)		D5  (PD5)		Шина данных 5
03 (DB6)		D6  (PD6)		Шина данных 6
04 (DB7)		D7  (PD7)		Шина данных 7
05 (A0)			A0  (PC0)		Команда(0)/Данные(1)
06 (R/W)		A1  (PC1)		Запись(0)/Чтение(1)
07 (E)			A2  (PC2)		Стробирование (_/)
08 (DB3)		D3  (PD3)		Шина данных 3
09 (DB2)		D2  (PD2)		Шина данных 2
10 (DB1)		D9  (PB1)		Шина данных 1
11 (DB0)		D8  (PB0)		Шина данных 0
12 (GND)		GND (GND)		Общий
13 (VO)			GND (GND)		Контрастность
14 (VCC)		5V  (5V)		Питание 5В
15 (K)			-				Подсветка - (Катод)
16 (A)			-				Подсветка + (Анод)
17 (RES)		A3  (PC3)		Сброс индикатора (0)
18 (CS)			D10 (PB2)		Выбор левого контроллера(1)/
								Выбор правого контроллера(0)
============================================================
*/



#define RIGHT_X0	61		// Координата по X, с которой начинается правая
							// половина индикатора (правый контроллер).
							// Соответствует 0-му адресу столбца правого
							// контроллера.
							
#define LEFT_X0		0x13	// Адрес столбца левого контроллера, которому
							// соответствует координата X=0 индикатора.

#define BUSY		7		// Номер бита для флага занятости

#define PAGE0		0xB8	// Код для установки текущей страницы (0..3)




// Определения для шины данных индикатора
///////////////////////////////////////////////////////////////////////////////
#define PORT_LCD_BUS_D2_D9 PORTD // Порт, используемый для вывода разрядов
									// D2...D9 шины данных
#define PORT_LCD_BUS_D0_D1 PORTB // Порт, используемый для вывода разрядов
									// D0,D1 шины данных
#define PIN_LCD_BUS_D2_D9 PIND // Порт, используемый для чтения разрядов
								// D2...D9 шины данных
#define PIN_LCD_BUS_D0_D1 PINB // Порт, используемый для чтения разрядов
								// D0,D1 шины данных
#define DDRX_LCD_BUS_D2_D9 DDRD // Порт, используемый для управления
								// разрядами D2...D9 шины данных
#define DDRX_LCD_BUS_D0_D1 DDRB // Порт, используемый для управления
								// разрядами D0,D1 шины данных

#define DATA_MASK_D2_D9	0xFC // Маска для разрядов D2...D9 шины данных
#define DATA_MASK_D0_D1	0x03 // Маска для разрядов D0...D1 шины данных




//Команды индикатора МЭЛТ MT-12232D
///////////////////////////////////////////////////////////////////////////////

// Включает индикатор
#define CMD_DISPLAY_ON       0xAF

// Выключает индикатор
////#define CMD_DISPLAY_OFF      0xAE

// Определяет верхнюю строку индикатора
#define CMD_START_LINE(x)    (0xC0 & (0x1F & (x)))

// Прямое соответствие адреса и позиции
#define CMD_ADC_SELECT_OFF   0xA0

// Обратное соответствие адреса и позиции
#define CMD_ADC_SELECT_ON    0xA1

// Статический режим управления
////#define CMD_STATIC_DRIVE_ON  0xA5

// Обычное управление
#define CMD_STATIC_DRIVE_OFF 0xA4

// Выбор мультиплекса
#define CMD_DUTY_SELECT_ON   0xA9

// Снятие флага RMW
#define CMD_CLEAR_RMW        0xEE

// Установка флага RMW
////#define CMD_SELECT_RMW       0xE0

// Строка и страница сбрасывается в 0
#define CMD_RESET            0xE2




#define LeftCS()	ON(_CS_) // Выбор левого контроллера
#define RightCS()	OFF(_CS_); // Выбор правого контроллера

#define STR_FLASH	TRUE
#define STR_RAM		FALSE

// Макрос обменивает между собой значения параметров a и b
#define SWAP(a, b)	{uint8_t temp; temp = a; a = b; b = temp;}




union Union32
{
	uint8_t byte[4];
	uint32_t value;
};




#if defined(LCD_USE_RAM_BUF)
static uint8_t	Buf[LCD_Y_RES / 8][LCD_X_RES]; // Буфер для индикатора
#endif

#if defined(LCD_USE_RAM_BUF)
// Координаты измененной области буфера, которая еще не передана в индикатор
static uint8_t xlChanged;
static uint8_t xhChanged;
static uint8_t ylChanged;
static uint8_t yhChanged;
#endif

static uint8_t DrawMode; // Режим вывода графики

// Массив, необходимый для вывода символов удвоенной высоты
static const uint8_t Bit4to8[] PROGMEM =
{
	0x00, 0x03, 0x0C, 0x0F, 0x30, 0x33, 0x3C, 0x3F,
	0xC0, 0xC3, 0xCC, 0xCF, 0xF0, 0xF3, 0xFC, 0xFF
};




///////////////////////////////////////////////////////////////////////////////
extern void __builtin_avr_delay_cycles(unsigned long Num);
#define CLOCK_PERIOD		(1000000000 / F_CPU)

// Задержка (наносекунды)
#define _delay_ns(ns)		__builtin_avr_delay_cycles((ns - 1) / CLOCK_PERIOD + 1)
////////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Переключение шины данных для работы в режиме входа + pullup
///////////////////////////////////////////////////////////////////////////////
static void DataDirectIn(void)
{
  DDRX_LCD_BUS_D2_D9 &= ~DATA_MASK_D2_D9;
  DDRX_LCD_BUS_D0_D1 &= ~DATA_MASK_D0_D1;
  PORT_LCD_BUS_D2_D9 |= DATA_MASK_D2_D9;
  PORT_LCD_BUS_D0_D1 |= DATA_MASK_D0_D1;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Переключение шины данных для работы в режиме выхода
///////////////////////////////////////////////////////////////////////////////
static void DataDirectOut(void)
{
	DDRX_LCD_BUS_D2_D9 |= DATA_MASK_D2_D9;
	DDRX_LCD_BUS_D0_D1 |= DATA_MASK_D0_D1;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Чтение данных с шины индикатора
///////////////////////////////////////////////////////////////////////////////
static uint8_t DataIn(void)
{
	return (PIN_LCD_BUS_D2_D9 & DATA_MASK_D2_D9) |
		(PIN_LCD_BUS_D0_D1 & DATA_MASK_D0_D1);
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Установка данных на шину индикатора
///////////////////////////////////////////////////////////////////////////////
static void DataOut(uint8_t Data)
{
	uint8_t bus;

	// Выводим разряды 2..9 данных
	bus = PORT_LCD_BUS_D2_D9;
	bus &= ~DATA_MASK_D2_D9;
	bus |= (Data & DATA_MASK_D2_D9);
	PORT_LCD_BUS_D2_D9 = bus;

	// Выводим разряды 0..1 данных
	bus = PORT_LCD_BUS_D0_D1;
	bus &= ~DATA_MASK_D0_D1;
	bus |= (Data & DATA_MASK_D0_D1);
	PORT_LCD_BUS_D0_D1 = bus;
}
///////////////////////////////////////////////////////////////////////////////




#if !defined(LCD_USE_RAM_BUF)
///////////////////////////////////////////////////////////////////////////////
// Чтение байта из индикатора.
///////////////////////////////////////////////////////////////////////////////
static uint8_t Read(void)
{
	uint8_t Data;

	DataDirectIn();
	ON(_RW_);
	ON(_A0_);

	// Не раньше, чем через 100нс можно установить E=0
	_delay_ns(100 + 20);	

	OFF(_E_);

	// Сигнал E при чтении необходимо удерживать в нуле не менее 300нс.
	// Не раньше, чем через 180нс после E=0 можно читать данные.
	_delay_ns(180 + 100);

	Data = DataIn();
	ON(_E_);
	DataDirectOut();

	return Data;
}
///////////////////////////////////////////////////////////////////////////////
#endif




///////////////////////////////////////////////////////////////////////////////
// Запись байта в индикатор.
///////////////////////////////////////////////////////////////////////////////
static void Write(uint8_t Data)
{
	OFF(_RW_);

	// Не раньше, чем через 100нс можно установить E=0
	_delay_ns(100 + 20);

	OFF(_E_);
	DataOut(Data);

	// После установки данных неоходимо не менее 160нс до установки E=1.
	// Сигнал E при записи неоходимо удерживать в нуле не менее 250нс.
	_delay_ns(250 + 25);

	ON(_E_);
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция чтения флага занятости индикатора.
///////////////////////////////////////////////////////////////////////////////
static void WaitReady(void)
{
	uint8_t Status;

	DataDirectIn();

	ON(_RW_);
	OFF(_A0_);

	// Не раньше, чем через 100нс можно установить E=0
	_delay_ns(100 + 20);

	do
	{
		OFF(_E_);

		// Сигнал E при чтении неоходимо удерживать в нуле не менее 300нс.
		// Не раньше, чем через 180нс можно читать данные.
		_delay_ns(180 + 100);

		Status = DataIn();

		ON(_E_);
	}
	while ((Status & (1 << BUSY)) != 0);	// Сидим в цикле пока не сбросится
											// флаг

	DataDirectOut();
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Запись команды в индикатор.
///////////////////////////////////////////////////////////////////////////////
static void SendCmd(uint8_t Data)
{
	WaitReady();
	OFF(_A0_);
	Write(Data);
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Запись данных в индикатор.
///////////////////////////////////////////////////////////////////////////////
static void SendData(uint8_t Data)
{
	WaitReady();
	ON(_A0_);
	Write(Data);
}
///////////////////////////////////////////////////////////////////////////////




#if defined(LCD_USE_RAM_BUF)
///////////////////////////////////////////////////////////////////////////////
// Из двух значений возвращает максимальное.
///////////////////////////////////////////////////////////////////////////////
static uint16_t Max(uint16_t a, uint16_t b)
{
	if (a > b) return a;
	return b;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Из двух значений возвращает минимальное.
///////////////////////////////////////////////////////////////////////////////
static uint16_t Min(uint16_t a, uint16_t b)
{
	if (a < b) return a;
	return b;
}
///////////////////////////////////////////////////////////////////////////////
#endif




#if !defined(LCD_USE_RAM_BUF)
///////////////////////////////////////////////////////////////////////////////
// Выводит изображение строки на индикатор.
// Параметры:
// X - Начальная координата по горизонтали (0...121).
// Y - Начальная координата по вертикали (0...31).
// idFont - Идентификатор шрифта (например: FONT_6x8). Идентификаторы
//          реализованных шрифтов объявлены в файле Font.h.
// Str - Адрес строки во FLASH, либо в RAM.
// Settings - Режим отображения строки. Может содержать комбинацию следующих
//        флагов:
//        LCD_TWICE_WIDTH (Удвоение ширины символов строки),
//        LCD_TWICE_HEIGHT (Удвоение высоты символов строки),
//        LCD_INVERSION (Инверсное изображение символов строки),
// fFLASH - Флаг, указывающий местонахождение строки, указанной параметром
//          Str. Если флаг равен TRUE, то это означает, что строка
//          находится во FLASH, иначе в RAM.
// ПРИМЕЧАНИЯ:
// -Начальной координатой является верхняя левая точка первого символа строки.
///////////////////////////////////////////////////////////////////////////////
static void StrToIndicator(uint8_t X, uint8_t Y, uint8_t idFont,
	const char *Str, uint8_t Settings, uint8_t fFLASH)
{
	uint8_t	col, row, j, num, m, data;
	uint8_t len;
	uint8_t chr;
	uint16_t tmp;
	uint8_t widthFont; // Ширина символа в пикселах
	uint8_t heightFont; // Высота символа в пикселах
	uint8_t cntByteChangeCol; // Количество изменяемых байтов буфера для
								// одного столбца символа
	uint8_t CntByteSymCol; // Количество байт в одном столбце символа
	union Union32 mask; // Маска для столбцов символа
	union Union32 column; // Столбец символа
	uint8_t const *addrFont; // Адрес шрифта 
	uint8_t twiceW = 0; // 1 = удвоение ширины символа
	uint8_t twiceH = 0; // 1 = удвоение высоты символа
	uint8_t inv = 0; // 1 = инверсное изображение символа
	int8_t offs;
	
	widthFont = FONT_Width(idFont); // Ширина шрифта 
	heightFont = FONT_Height(idFont); // Высота шрифта

	if (Settings & LCD_TWICE_WIDTH)
		twiceW = 1; // Удвоенная ширина 

	if (Settings & LCD_TWICE_HEIGHT)
		twiceH = 1; // Удвоенная высота

	if (Settings & LCD_INVERSION)
		inv = 1; // Инверсное изображение символов 

	if (fFLASH)
		tmp = strlen_P(Str); //Вычисляем длину строки во FLASH
	else
		tmp = strlen(Str); // Вычисляем длину строки в RAM

	if (tmp < 255) len = tmp; else len = 255;

	// Получаем адрес шрифта (массива байтов, представляющего собой
	// графическое представление символов)
	addrFont = FONT_Addr(idFont) + 2;

	// Вычисляем маску, которую будем использовать для столбцов символа.
	// В этой маске количество единиц равно высоте выбранного шрифта	
	mask.value = 1;
	mask.value <<= (heightFont << twiceH);
	mask.value--; // Получаем маску в виде всех единиц для значимых точек
					// столбца символа
	mask.value <<= Y % 8; // Сдвигаем маску с учетом координаты Y
	
	// Вычисляем количество байт, требуемых для одного столбца символа
	// (без учета удвоения по высоте и ширине)
	CntByteSymCol = (heightFont - 1) / 8 + 1;

	// Т.к. символ может располагаться начиная с любой координаты, а не только
	// с кратной размеру байта (например, один столбец символа с высотой 8
	// точек может располагаться в двух байтах), то необходимо вычислить
	// количество изменяемых байтов для одного столбца символа.

	cntByteChangeCol = 0;

	for (num = 0; num < sizeof(mask); num++)
	{
		if (mask.byte[num] != 0) cntByteChangeCol++;
		else break;
	}
	
	mask.value = ~mask.value; // Инвертируем маску

	// В зависимости от координаты X выбираем левый или правый контроллер

	if (X < RIGHT_X0)
	{
		offs = LEFT_X0;
		LeftCS();
	}
	else
	{
		offs = -RIGHT_X0;
		RightCS();
	}

	// Цикл по каждому символу строки
	///////////////////////////////////////////////////////////////////////////
	for (j = 0; j < len; j++)
	{
		if (X >= LCD_X_RES) break;
		
		if (fFLASH)
			// Если символ строки находится во FLASH
			chr = pgm_read_byte(&Str[j]);
		else
			// Если символ строки находится в ОЗУ 
			chr = Str[j];

		// Корректируем очередной код символа в соответствии с кодировкой
		///////////////////////////////////////////////////////////////////////

		if ((chr >= 0x20) && (chr <= 0x7F))
		{
			// Смещение в таблице для символов ASCII[0x20-0x7F]
			chr -= 32;
		}
		else if (chr >= 0xC0)
		{
			// Смещение в таблице для символов CP1251[0xC0-0xFF]
			chr -= 96;
		}
		else
		{
			// Остальные игнорируем (их нет в таблице для экономии памяти)
			chr = 0; // Пробел
		}


		// Цикл по всем столбцам символа
		///////////////////////////////////////////////////////////////////////
		for (col = 0; col < widthFont; col++)
		{
			if (X >= LCD_X_RES) break;

			column.value = 0;

			// Читаем байты для одного очередного столбца символа
			for (num = 0; num < CntByteSymCol; num++)
			{
				if (twiceH)
				{
					m = pgm_read_byte(&(addrFont[chr * widthFont *
						CntByteSymCol + col * CntByteSymCol + num]));

					column.byte[num * 2] =
						pgm_read_byte(&(Bit4to8[m & 0xF]));
					column.byte[num * 2 + 1] =
						pgm_read_byte(&(Bit4to8[m >> 4]));
				}
				else
				{
					column.byte[num] =
						pgm_read_byte(&(addrFont[chr * widthFont *
							CntByteSymCol + col * CntByteSymCol + num]));
				}
			}

			// Сдвигаем столбец с учетом координаты Y
			column.value <<= Y % 8;
			
			// Если инверсное изображение, то инвертируем пикселы столбца
			if (inv)
			{
				column.value ^= ~mask.value;
			}
			
			// Пишем столбец в буфер
			for (m = 0; m <= twiceW; m++)
			{
				if (X < LCD_X_RES)
				{
					if (X == RIGHT_X0)
					{
						RightCS();
						offs = -RIGHT_X0;
					}

					// Цикл по байтам одного столбца
					for (num = 0; num < cntByteChangeCol; num++)
					{
						row = Y + num * 8;
						if (row < LCD_Y_RES)
						{
							row /= 8;
							SendCmd(PAGE0 + row);
							SendCmd(X + offs);
							Read();
							data = (Read() & mask.byte[num]) |
								column.byte[num];
							SendCmd(X + offs);
							SendData(data);
						}
					}
					X++;
				}
				else
				{
					X = LCD_X_RES;
					break;
				}
			}
		}
	}

	if (X > LCD_X_RES) X = LCD_X_RES;
}
///////////////////////////////////////////////////////////////////////////////
#endif




#if defined(LCD_USE_RAM_BUF)
///////////////////////////////////////////////////////////////////////////////
// Формирует изображение строки в буфере, расположенном в ОЗУ.
// Параметры:
// X - Начальная координата по горизонтали (0...121)
// Y - Начальная координата по вертикали (0...31)
// idFont - Идентификатор шрифта (например: FONT_6x8). Идентификаторы
//          реализованных шрифтов объявлены в файле Font.h
// Str - Адрес строки во FLASH, либо в RAM
// Settings - Режим отображения строки. Может содержать комбинацию
//        следующих флагов:
//        LCD_TWICE_WIDTH (Удвоение ширины символов строки)
//        LCD_TWICE_HEIGHT (Удвоение высоты символов строки)
//        LCD_INVERSION (Инверсное изображение символов строки)
// fFLASH - Флаг, указывающий местонахождение строки, указанной параметром
//          Str. Если флаг равен TRUE, то это означает, что строка
//          находится во FLASH, иначе в RAM.
// ПРИМЕЧАНИЯ:
// -Начальной координатой является верхняя левая точка первого символа строки.
///////////////////////////////////////////////////////////////////////////////
static void StrBuf(uint8_t X, uint8_t Y, uint8_t idFont, const char *Str,
	uint8_t Settings, uint8_t fFLASH)
{
	uint8_t	col, j, num, m, data, row;
	uint8_t len;
	uint8_t chr;
	uint16_t tmp;
	uint8_t widthFont; // Ширина символа в пикселах
	uint8_t heightFont; // Высота символа в пикселах
	uint8_t cntByteChangeCol; // Количество изменяемых байтов буфера для
								// одного столбца символа
	uint8_t cntByteSymCol; // Количество байт в одном столбце символа
	union Union32 mask; // Маска для столбцов символа
	union Union32 column; // Столбец символа
	uint8_t const *addrFont; // Адрес шрифта
	uint8_t twiceW = 0; // 1 = удвоение ширины символа
	uint8_t twiceH = 0; // 1 = удвоение высоты символа
	uint8_t inv = 0; // 1 = инверсное изображение символа
	
	widthFont = FONT_Width(idFont); // Ширина символов шрифта
	heightFont = FONT_Height(idFont); // Высота символов шрифта

	if (Settings & LCD_TWICE_WIDTH)
		twiceW = 1; // Удвоенная ширина

	if (Settings & LCD_TWICE_HEIGHT)
		twiceH = 1; // Удвоенная высота

	if (Settings & LCD_INVERSION)
		inv = 1; // Инверсное изображение символов
	
	if (fFLASH)
		tmp = strlen_P(Str); // Вычисляем длину строки во FLASH
	else
		tmp = strlen(Str); // Вычисляем длину строки в RAM

	if (tmp < 255) len = tmp; else len = 255;

	// Вычисляем новые координаты точек для изменяемой области буфера
	xlChanged = Min(X, xlChanged);
	tmp = Min(LCD_X_RES, X + len * (widthFont << twiceW));
	xhChanged = Max(tmp, xhChanged);

	ylChanged = Min(Y, ylChanged);
	tmp = Min(LCD_Y_RES, Y + (heightFont << twiceH));
	yhChanged = Max(tmp, yhChanged);

	// Получаем адрес шрифта (массива байтов, представляющего собой
	// графическое представление символов)
	addrFont = FONT_Addr(idFont) + 2;

	// Вычисляем маску, которую будем использовать для столбцов символа.
	// В этой маске количество единиц равно высоте выбранного шрифта.
	mask.value = 1;
	mask.value <<= (heightFont << twiceH);
	mask.value--; // Получаем маску в виде всех единиц для значимых
					// точек столбца символа

	#if defined(LCD_ROTATE)
	// Получаем маску, сдвинутую к старшим разрядам
	mask.value <<= (sizeof(mask) * 8 - (heightFont << twiceH)) - Y % 8;
	#else
	mask.value <<= Y % 8; // Сдвигаем маску с учетом координаты Y
	#endif
	
	// Вычисляем количество байт, требуемых для одного столбца символа
	// (без учета масштабирования)
	cntByteSymCol = (heightFont - 1) / 8 + 1;

	// Т.к. символ может располагаться начиная с любой координаты, а не только
	// с кратной размеру байта (например, один столбец символа с высотой 8
	// точек может располагаться в двух байтах), то необходимо вычислить
	// количество изменяемых байтов в буфере для одного столбца символа.

	// Подсчитываем количество байт для одного столбца символа, которые будут
	// подвергнуты изменению

	cntByteChangeCol = 0;

	#if defined(LCD_ROTATE)
	for (num = sizeof(mask); num > 0; num--)
	{
		if (mask.byte[num - 1] != 0) cntByteChangeCol++;
		else break;
	}
	#else
	for (num = 0; num < sizeof(mask); num++)
	{
		if (mask.byte[num] != 0) cntByteChangeCol++;
		else break;
	}
	#endif
	
	mask.value = ~mask.value; // Инвертируем маску
	
	// Цикл по каждому символу строки
	///////////////////////////////////////////////////////////////////////////
	for (j = 0; j < len; j++)
	{
		if (X >= LCD_X_RES) break;
		
		if (fFLASH)
			// Если символ строки находится во FLASH
			chr = pgm_read_byte(&Str[j]);
		else
			// Если символ строки находится в ОЗУ
			chr = Str[j];

		// Корректируем очередной код символа в соответствии с кодировкой
		///////////////////////////////////////////////////////////////////////
		if ((chr >= 0x20) && (chr <= 0x7F))
		{
			// Смещение в таблице для символов ASCII[0x20-0x7F]
			chr -= 32;
		}
		else if (chr >= 0xC0)
		{
			// Смещение в таблице для символов CP1251[0xC0-0xFF]
			chr -= 96;
		}
		else
		{
			// Остальные игнорируем (их нет в таблице для экономии памяти)
			chr = 0; // Пробел			
		}

		// Цикл по всем столбцам символа
		///////////////////////////////////////////////////////////////////////
		for (col = 0; col < widthFont; col++)
		{
			if (X >= LCD_X_RES) break;

			column.value = 0;

			// Читаем байты для одного очередного столбца символа
			for (num = 0; num < cntByteSymCol; num++)
			{
				if (twiceH) // Если удвоенная высота символа
				{
					m = pgm_read_byte(&(addrFont[chr * widthFont *
						cntByteSymCol + col * cntByteSymCol + num]));
					
					#if defined(LCD_ROTATE)
					column.byte[(sizeof(column) - 1) - (num * 2)] =
						pgm_read_byte(&(Bit4to8[m >> 4]));
					column.byte[(sizeof(column) - 1) - (num * 2 + 1)] =
						pgm_read_byte(&(Bit4to8[m & 0xF]));
					#else
					column.byte[num * 2] =
						pgm_read_byte(&(Bit4to8[m & 0xF]));
					column.byte[num * 2 + 1] =
						pgm_read_byte(&(Bit4to8[m >> 4]));
					#endif
				}
				else
				{
					#if defined(LCD_ROTATE)
					column.byte[(sizeof(column) - 1) - num] =
						pgm_read_byte(&(addrFont[chr * widthFont *
							cntByteSymCol + col * cntByteSymCol + num]));
					#else
					column.byte[num] =
						pgm_read_byte(&(addrFont[chr * widthFont *
							cntByteSymCol + col * cntByteSymCol + num]));
					#endif
				}
			}

			// Сдвигаем столбец с учетом координаты Y
			#if defined(LCD_ROTATE)
			column.value >>= Y % 8;
			#else
			column.value <<= Y % 8;
			#endif
			
			// Если инверсное изображение, то инвертируем пикселы столбца
			if (inv)
			{
				column.value ^= ~mask.value;
			}
			
			// Пишем столбец в буфер
			for (m = 0; m <= twiceW; m++)
			{
				if (X < LCD_X_RES)
				{
					// Цикл по изменяемым байтам буфера для одного столбца
					// символа
					for (num = 0; num < cntByteChangeCol; num++)
					{
						row = Y + num * 8;
						if (row < LCD_Y_RES)
						{
							#if defined(LCD_ROTATE)
							row = (LCD_Y_RES / 8 - 1) - row / 8;
							data = Buf[row][(LCD_X_RES - 1) - X];
							data &= mask.byte[(sizeof(mask) - 1) - num];
							data |= column.byte[(sizeof(column) - 1) - num];
							Buf[row][(LCD_X_RES - 1) - X] = data;
							#else
							row /= 8;
							data = Buf[row][X];
							data &= mask.byte[num];
							data |= column.byte[num];
							Buf[row][X] = data;
							#endif
						}
					}
					X++;
				}
				else
				{
					X = LCD_X_RES;
					break;
				}
			}
		}
	}
	if (X > LCD_X_RES) X = LCD_X_RES;
}
///////////////////////////////////////////////////////////////////////////////
#endif




///////////////////////////////////////////////////////////////////////////////
// Инициализация индикатора МЭЛТ MT-12232D
///////////////////////////////////////////////////////////////////////////////
void LCD_Init(void)
{
	PORT_LCD_BUS_D2_D9 |= DATA_MASK_D2_D9;
	DDRX_LCD_BUS_D2_D9 |= DATA_MASK_D2_D9;
	PORT_LCD_BUS_D0_D1 |= DATA_MASK_D0_D1;
	DDRX_LCD_BUS_D0_D1 |= DATA_MASK_D0_D1;
	
	DRIVER(_A0_, OUT); ON(_A0_); // A0 = 1
	DRIVER(_RW_, OUT); ON(_RW_); // RW = 1
	DRIVER(_E_, OUT); ON(_E_); // E = 1
	DRIVER(_RES_, OUT); ON(_RES_); // RES = 1
	DRIVER(_CS_, OUT); ON(_CS_); // CS = 1

	OFF(_RES_);
	_delay_ms(400);
	ON(_RES_);
	_delay_ms(400);
	
	LeftCS();
	SendCmd(CMD_CLEAR_RMW);
	SendCmd(CMD_STATIC_DRIVE_OFF);
	SendCmd(CMD_DUTY_SELECT_ON);
	SendCmd(CMD_DISPLAY_ON);
	SendCmd(CMD_ADC_SELECT_ON);
	SendCmd(CMD_RESET);
	SendCmd(CMD_START_LINE(0));


	RightCS();
	SendCmd(CMD_CLEAR_RMW);
	SendCmd(CMD_STATIC_DRIVE_OFF);
	SendCmd(CMD_DUTY_SELECT_ON);
	SendCmd(CMD_DISPLAY_ON);
	SendCmd(CMD_ADC_SELECT_OFF);
	SendCmd(CMD_RESET);	
	SendCmd(CMD_START_LINE(0));

	DrawMode = LCD_OR;

	#if defined(LCD_USE_RAM_BUF)
	// Инициализация координат измененой области буфера
	xlChanged = 0;
	xhChanged = LCD_X_RES;
	ylChanged = 0;
	yhChanged = LCD_Y_RES;
	#endif
}
///////////////////////////////////////////////////////////////////////////////




#if defined(LCD_USE_RAM_BUF)
///////////////////////////////////////////////////////////////////////////////
// Выводит содержимое измененной области буфера в индикатор.
// Данные выводятся по строкам сначала через левый контроллер, затем через
// правый
///////////////////////////////////////////////////////////////////////////////
void LCD_Update(void)
{
	uint8_t i, x, y;

	// Если в буфере изменилась информация, то ее нужно передать в индикатор
	if ((xhChanged > xlChanged) && (yhChanged > ylChanged))
	{
		#if defined(LCD_ROTATE)
		if ((LCD_X_RES - xhChanged) < RIGHT_X0)
		{
			LeftCS();
			x = Min(LCD_X_RES - xlChanged, RIGHT_X0);
			y = LCD_Y_RES - yhChanged;
			while (y < (LCD_Y_RES - ylChanged))
			{
				// Устанавливаем начальный адрес по Y
				SendCmd(PAGE0 | (y / 8));
				
				// Устанавливаем начальный адрес по X
				SendCmd(LEFT_X0 + (LCD_X_RES - xhChanged));
				
				for (i = LCD_X_RES - xhChanged; i < x; i++)
				{
					SendData(Buf[y / 8][i]);
				}
				y += (8 - (y % 8));
			}
		}
		#else
		if (xlChanged < RIGHT_X0)
		{
			LeftCS();
			x = Min(xhChanged, RIGHT_X0);
			y = ylChanged;
			while (y < yhChanged)
			{
				// Устанавливаем начальный адрес по Y
				SendCmd(PAGE0 | (y / 8));
				
				// Устанавливаем начальный адрес по X
				SendCmd(LEFT_X0 + xlChanged);
				
				// Передаем данные в индикатор
				for (i = xlChanged; i < x; i++)
				{
					SendData(Buf[y / 8][i]);
				}
				y += (8 - (y % 8));
			}
		}
		#endif


		#if defined(LCD_ROTATE)
		if ((LCD_X_RES - xlChanged) > RIGHT_X0)
		{
			RightCS();
			x = Max(LCD_X_RES - xhChanged, RIGHT_X0);
			y = LCD_Y_RES - yhChanged;
			while (y < (LCD_Y_RES - ylChanged))
			{
				// Устанавливаем начальный адрес по Y
				SendCmd(PAGE0 | (y / 8));
				
				// Устанавливаем начальный адрес по X
				SendCmd(x - RIGHT_X0);
				
				// Передаем данные в индикатор
				for (i = x; i < LCD_X_RES - xlChanged; i++)
				{
					SendData(Buf[y / 8][i]);
				}
				y += (8 - (y % 8));
			}
		}
		#else
		if (xhChanged > RIGHT_X0)
		{
			RightCS();
			x = Max(xlChanged, RIGHT_X0);
			y = ylChanged;
			while (y < yhChanged)
			{
				// Устанавливаем начальный адрес по Y
				SendCmd(PAGE0 | (y / 8));
				
				// Устанавливаем начальный адрес по X
				SendCmd(x - RIGHT_X0);
				
				// Передаем данные в индикатор
				for (i = x; i < xhChanged; i++)
				{
					SendData(Buf[y / 8][i]);
				}
				y += (8 - (y % 8));
			}
		}
		#endif

		// Освобождаем координаты измененной области буфера
		xlChanged = LCD_X_RES;
		xhChanged = 0;
		ylChanged = LCD_Y_RES;
		yhChanged = 0;
	}
}
///////////////////////////////////////////////////////////////////////////////
#endif




#if defined(LCD_USE_RAM_BUF)
///////////////////////////////////////////////////////////////////////////////
// Очищает область буфера с указанными координатами.
// Параметры:
// X1 - Координата верхнего левого угла очищаемой области по горизонтали
//      (0...121),
// Y1 - Координата верхнего левого угла очищаемой области по вертикали
//      (0...31),
// X2 - Координата нижнего правого угла очищаемой области по горизонтали
//      (0...121),
// Y1 - Координата нижнего правого угла очищаемой области по вертикали
//      (0...31).
//
// Пример:
// LCD_ClearBuf(0, 0, 121, 31); // Очистить весь буфер
// LCD_Update(); // Вывод измененной части буфера в индикатор
///////////////////////////////////////////////////////////////////////////////
void LCD_ClearBuf(uint8_t X1, uint8_t Y1, uint8_t X2, uint8_t Y2)
{
	uint8_t sizeY;
	union Union32 mask;
	uint8_t cntByteChangeCol;
	uint8_t x, num;

	// Разбираемся со входными параметрами
	
	// Если левая координата больше правой, то меняем их значения между собой
	if (X1 > X2) SWAP(X1, X2)
							
	// Если верхняя координата больше нижней, то меняем их значения между собой
	if (Y1 > Y2) SWAP(Y1, Y2)

	if ((X1 >= LCD_X_RES) || (Y1 >= LCD_Y_RES)) return;
	if (X2 >= LCD_X_RES) X2 = LCD_X_RES - 1;
	if (Y2 >= LCD_Y_RES) Y2 = LCD_Y_RES - 1;
	X2++;
	Y2++;

	// Вычисляем новые координаты для изменяемой области буфера 
	xlChanged = Min(X1, xlChanged);
	xhChanged = Max(X2, xhChanged);
	ylChanged = Min(Y1, ylChanged);
	yhChanged = Max(Y2, yhChanged);

	// Вычисляем размер очищаемой области по вертикали
	sizeY = Y2 - Y1;
	
	// Вычисляем маску, которую будем использовать для очистки столбцов.
	// В этой маске количество единиц равно высоте очищаемой области.
	mask.value = 1;
	mask.value <<= sizeY;
	mask.value--; // Получаем маску в виде всех единиц для значимых
					// точек столбцов очищаемой области
	#if defined(LCD_ROTATE)
	// Получаем маску, сдвинутую к старшим разрядам
	mask.value <<= sizeof(mask) * 8 - sizeY - Y1 % 8;
	#else
	mask.value <<= Y1 % 8;
	#endif

	// Подсчитываем количество байт для одного столбца очищаемой области,
	// которые будут подвергнуты изменению.

	cntByteChangeCol = 0;

	#if defined(LCD_ROTATE)
	for (num = sizeof(mask); num > 0; num--)
	{
		if (mask.byte[num - 1] != 0) cntByteChangeCol++;
		else break;
	}
	#else
	for (num = 0; num < sizeof(mask); num++)
	{
		if (mask.byte[num] != 0) cntByteChangeCol++;
		else break;
	}
	#endif
	
	mask.value = ~mask.value; // Инвертируем маску
	
	// Цикл по каждому столбцу очищаемой области
	for (x = X1; x < X2; x++)
	{
		for (num = 0; num < cntByteChangeCol; num++)
		{
			#if defined(LCD_ROTATE)
			Buf[(LCD_Y_RES - 1 - (Y1 + num * 8)) / 8][LCD_X_RES - 1 - x] &=
				mask.byte[sizeof(mask) - 1 - num];
			#else
			Buf[(Y1 + num * 8) / 8][x] &= mask.byte[num];
			#endif
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
#endif




///////////////////////////////////////////////////////////////////////////////
// Очищает область индикатора с указанными координатами.
// Параметры:
// X1 - Координата верхнего левого угла очищаемой области по горизонтали
//      (0...121),
// Y1 - Координата верхнего левого угла очищаемой области по вертикали
//      (0...31),
// X2 - Координата нижнего правого угла очищаемой области по горизонтали
//      (0...121),
// Y1 - Координата нижнего правого угла очищаемой области по вертикали
//      (0...31).
///////////////////////////////////////////////////////////////////////////////
void LCD_Clear(uint8_t X1, uint8_t Y1, uint8_t X2, uint8_t Y2)
{
	LCD_ClearBuf(X1, Y1, X2, Y2); // Очистить область буфера
	LCD_Update(); // Вывод измененной части буфера в индикатор
}
///////////////////////////////////////////////////////////////////////////////




#if defined(LCD_USE_RAM_BUF)
///////////////////////////////////////////////////////////////////////////////
// Формирует изображение строки в буфере, расположенном в ОЗУ по координатам,
// указанным параметрами X и Y.
// Параметры:
// X - Начальная координата по горизонтали (0...121).
// Y - Начальная координата по вертикали (0...31).
// idFont - Идентификатор шрифта (например: FONT_6x8). Идентификаторы
//          реализованных шрифтов объявлены в файле Font.h.
// Str - Адрес строки в ОЗУ.
// Settings - Режим отображения строки. Может содержать комбинацию
//        следующих флагов:
//        LCD_TWICE_WIDTH (Удвоение ширины символов строки)
//        LCD_TWICE_HEIGHT (Удвоение высоты символов строки)
//        LCD_INVERSION (Инверсное изображение символов строки)
// ПРИМЕЧАНИЯ:
// -Начальной координатой является верхняя левая точка первого символа строки.
///////////////////////////////////////////////////////////////////////////////
void LCD_StrBuf(uint8_t X, uint8_t Y, uint8_t idFont, char *Str,
	uint8_t Settings)
{
	StrBuf(X, Y, idFont, Str, Settings, STR_RAM);
}
///////////////////////////////////////////////////////////////////////////////
#endif




///////////////////////////////////////////////////////////////////////////////
// Выводит изображение строки на индикатор по координатам, указанным параметрами
// X и Y.
// Параметры:
// X - Начальная координата по горизонтали (0...121).
// Y - Начальная координата по вертикали (0...31).
// idFont - Идентификатор шрифта (например: FONT_6x8). Идентификаторы
//          реализованных шрифтов объявлены в файле Font.h
// Str - Адрес строки в ОЗУ.
// Settings - Режим отображения строки. Может содержать комбинацию
//        следующих флагов:
//        LCD_TWICE_WIDTH (Удвоение ширины символов строки)
//        LCD_TWICE_HEIGHT (Удвоение высоты символов строки)
//        LCD_INVERSION (Инверсное изображение символов строки)
// ПРИМЕЧАНИЯ:
// -Начальной координатой является верхняя левая точка первого символа строки.
///////////////////////////////////////////////////////////////////////////////
void LCD_Str(uint8_t X, uint8_t Y, uint8_t idFont, char *Str, uint8_t Settings)
{
	#if defined(LCD_USE_RAM_BUF)
	LCD_StrBuf(X, Y, idFont, Str, Settings);
	LCD_Update();
	#else
	StrToIndicator(X, Y, idFont, Str, Settings, STR_RAM);
	#endif
}
///////////////////////////////////////////////////////////////////////////////




#if defined(LCD_USE_RAM_BUF)
///////////////////////////////////////////////////////////////////////////////
// Формирует изображение строки в буфере, расположенном в ОЗУ по координатам,
// указанным параметрами X и Y.
// Параметры:
// X - Начальная координата по горизонтали (0...121).
// Y - Начальная координата по вертикали (0...31).
// idFont - Идентификатор шрифта (например: FONT_6x8). Идентификаторы
//          реализованных шрифтов объявлены в файле Font.h.
// Str_P - Адрес строки во FLASH.
// Settings - Режим отображения строки. Может содержать комбинацию
//        следующих флагов:
//        LCD_TWICE_WIDTH (Удвоение ширины символов строки)
//        LCD_TWICE_HEIGHT (Удвоение высоты символов строки)
//        LCD_INVERSION (Инверсное изображение символов строки)
// ПРИМЕЧАНИЯ:
// -Начальной координатой является верхняя левая точка первого символа строки.
///////////////////////////////////////////////////////////////////////////////
void LCD_StrBuf_P(uint8_t X, uint8_t Y, uint8_t idFont, const char *Str_P,
	uint8_t Settings)
{
	return StrBuf(X, Y, idFont, Str_P, Settings, STR_FLASH);
}
///////////////////////////////////////////////////////////////////////////////
#endif




///////////////////////////////////////////////////////////////////////////////
// Выводит изображение строки в индикатор по координатам, указанным параметрами
// X и Y.
// Параметры:
// X - Начальная координата по горизонтали (0...121).
// Y - Начальная координата по вертикали (0...31).
// idFont - Идентификатор шрифта (например: FONT_6x8). Идентификаторы
//          реализованных шрифтов объявлены в файле Font.h
// Str_P - Адрес строки во FLASH.
// Settings - Режим отображения строки. Может содержать комбинацию
//        следующих флагов:
//        LCD_TWICE_WIDTH (Удвоение ширины символов строки)
//        LCD_TWICE_HEIGHT (Удвоение высоты символов строки)
//        LCD_INVERSION (Инверсное изображение символов строки)
// ПРИМЕЧАНИЯ:
// -Начальной координатой является верхняя левая точка первого символа
//  строки.
//
// ПРИМЕР1:
// LCD_Str_P(3, 12, FONT_6x8, PSTR("СТРОКА"), 0);
//
// ПРИМЕР2:
// // Вывод строки c удвоенной шириной и высотой.
// const char Str_P[] PROGMEM = "СТРОКА"; // Объявление строки
// LCD_Str_P(0, 0, FONT_8x16, Str_P, LCD_TWICE_WIDTH | LCD_TWICE_HEIGHT);
///////////////////////////////////////////////////////////////////////////////
void LCD_Str_P(uint8_t X, uint8_t Y, uint8_t idFont, const char *Str_P,
	uint8_t Settings)
{
	#if defined(LCD_USE_RAM_BUF)
	LCD_StrBuf_P(X, Y, idFont, Str_P, Settings);
	LCD_Update();
	#else
	StrToIndicator(X, Y, idFont, Str_P, Settings, STR_FLASH);
	#endif
}
///////////////////////////////////////////////////////////////////////////////




#if defined(LCD_USE_RAM_BUF)
///////////////////////////////////////////////////////////////////////////////
// Формирует изображение символа в буфере, расположенном в ОЗУ по координатам,
// указанным параметрами X и Y.
// Параметры:
// X - Начальная координата по горизонтали (0...121).
// Y - Начальная координата по вертикали (0...31).
// idFont - Идентификатор шрифта (например: FONT_6x8). Идентификаторы
//          реализованных шрифтов объявлены в файле Font.h.
// Chr - Код символа.
// Settings - Режим отображения символа. Может содержать комбинацию
//        следующих флагов:
//        LCD_TWICE_WIDTH (Удвоение ширины символа)
//        LCD_TWICE_HEIGHT (Удвоение высоты символа)
//        LCD_INVERSION (Инверсное изображение символа)
// ПРИМЕЧАНИЯ:
// -Начальной координатой является верхняя левая точка первого символа строки.
///////////////////////////////////////////////////////////////////////////////
void LCD_ChrBuf(uint8_t X, uint8_t Y, uint8_t idFont, char Chr,
	uint8_t Settings)
{
	char str[2];
	str[0] = Chr;
	str[1] = '\0';
	StrBuf(X, Y, idFont, str, Settings, STR_RAM);
}
///////////////////////////////////////////////////////////////////////////////
#endif




///////////////////////////////////////////////////////////////////////////////
// Выводит изображение символа на индикатор по координатам, указанным
// параметрами X и Y.
// Параметры:
// X - Начальная координата по горизонтали (0...121).
// Y - Начальная координата по вертикали (0...31).
// idFont - Идентификатор шрифта (например: FONT_6x8). Идентификаторы
//          реализованных шрифтов объявлены в файле Font.h
// Chr - Код символа.
// Settings - Режим отображения символа. Может содержать комбинацию
//        следующих флагов:
//        LCD_TWICE_WIDTH (Удвоение ширины символа)
//        LCD_TWICE_HEIGHT (Удвоение высоты символа)
//        LCD_INVERSION (Инверсное изображение символа)
// ПРИМЕЧАНИЯ:
// -Начальной координатой является верхняя левая точка первого символа строки.
///////////////////////////////////////////////////////////////////////////////
void LCD_Chr(uint8_t X, uint8_t Y, uint8_t idFont, char Chr, uint8_t Settings)
{
	#if defined(LCD_USE_RAM_BUF)
	LCD_ChrBuf(X, Y, idFont, Chr, Settings);
	LCD_Update();
	#else
	char str[2];
	str[0] = Chr;
	str[1] = '\0';	
	StrToIndicator(X, Y, idFont, str, Settings, STR_RAM);
	#endif
}
///////////////////////////////////////////////////////////////////////////////




// ГРАФИКА
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Установка режима отрисовки графики.
// Параметр:
// Mode - Может принимать одно из следующих значений:
//        LCD_OR,
//        LCD_AND,
//        LCD_XOR.
///////////////////////////////////////////////////////////////////////////////
void LCD_DrawMode(uint8_t Mode)
{
	DrawMode = Mode;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Выводит один пиксел на индикатор.
// Параметры:
// X - Координата по горизонтали (0...121).
// Y - Координата по вертикали (0...31).
///////////////////////////////////////////////////////////////////////////////
void LCD_Pixel(uint8_t X, uint8_t Y)
{
	uint8_t addr;
	uint8_t mask;
	uint8_t data;
	uint8_t row;

	if ((X >= LCD_X_RES) || (Y >= LCD_Y_RES)) return;
	
	#if defined(LCD_ROTATE)
	mask = 0x80 >> (Y % 8);
	row = ((LCD_Y_RES - 1) - Y) / 8;
	X = (LCD_X_RES - 1) - X;
	#else
	mask = 1 << (Y % 8);
	row = Y / 8;
	#endif

	if (X < RIGHT_X0)
	{
		LeftCS();
		addr = X + LEFT_X0;
	}
	else
	{
		RightCS();
		addr = X - RIGHT_X0;
	}

	SendCmd(PAGE0 + row); // Y

	#if defined(LCD_USE_RAM_BUF)
	data = Buf[row][X];
	#else
	SendCmd(addr);
	Read();
	data = Read();
	#endif

	switch(DrawMode)
	{
	case LCD_OR : data |= mask; break;
	case LCD_AND: data &= ~mask; break;
	case LCD_XOR : data ^= mask; break;
	}
	
	#if defined(LCD_USE_RAM_BUF)
	Buf[row][X] = data;
	#endif
	
	SendCmd(addr); // X
	
	SendData(data);
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Рисует линию между двумя точками на индикаторе (алгоритм Брезенхэма).
// Параметры:
// X1 - Координата первой точки по горизонтали (0...121),
// Y1 - Координата первой точки по вертикали (0...31),
// X2 - Координата последней точки по горизонтали (0...121),
// Y2 - Координата последней точки по вертикали (0...31).
///////////////////////////////////////////////////////////////////////////////
void LCD_Line(uint8_t X1, uint8_t Y1, uint8_t X2, uint8_t Y2)
{
	int16_t dX, dY;
	int16_t stepX, stepY;
	int16_t fraction;

	// dY   Y2 - Y1
	// -- = -------
	// dX   X2 - X1

	dY = Y2 - Y1;
	dX = X2 - X1;

	if (dY < 0)
	{
		// dY отрицательное
		dY = -dY;
		stepY = -1;
	}
	else
	{
		// dY положительное
		stepY = 1;
	}

	if (dX < 0)
	{
		// dX отрицательное
		dX = -dX;
		stepX = -1;
	}
	else
	{
		// dX положительное
		stepX = 1;
	}

	dX <<= 1;
	dY <<= 1;

	LCD_Pixel(X1, Y1);

	// Рисуем следующие точки до конца
	if (dX > dY)
	{
		fraction = dY - (dX >> 1);
		while (X1 != X2)
		{
			if (fraction >= 0)
			{
				Y1 += stepY;
				fraction -= dX;
			}
			X1 += stepX;
			fraction += dY;

			LCD_Pixel(X1, Y1);
		}
	}
	else
	{
		fraction = dX - (dY >> 1);
		while (Y1 != Y2)
		{
			if (fraction >= 0)
			{
				X1 += stepX;
				fraction -= dY;
			}
			Y1 += stepY;
			fraction += dX;

			LCD_Pixel(X1, Y1);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Рисует окружность с центром, координаты которого указаны параметрами X и Y с
// радиусом R.
// Параметры:
// X - Координата центра окружности по горизонтали (0...121),
// Y - Координата центра окружности по вертикали (0...31),
// R - Радиус окружности (0...121).
///////////////////////////////////////////////////////////////////////////////
void LCD_Circle(uint8_t X, uint8_t Y, uint8_t R)
{
	int16_t  d;
	int8_t  xc, yc;

	yc = R;
	d = 3 - ((int16_t)R << 1);
	xc = 0;
	
	while (xc <= yc)
	{
		LCD_Pixel(xc + X, yc + Y);

		if (yc != 0)
			LCD_Pixel(xc + X, -yc + Y);

		if ((xc != 0) && (yc != 0))
			LCD_Pixel(-xc + X, -yc + Y);

		if (xc != 0)
			LCD_Pixel(-xc + X, yc + Y);

		if (xc != yc)
			LCD_Pixel(yc + X, xc + Y);

		if ((xc != 0) && (xc != yc))
			LCD_Pixel(yc + X, -xc + Y);

		if ((xc != 0) && (yc != 0) && (xc != yc))
			LCD_Pixel(-yc + X, -xc + Y);

		if ((yc != 0) && (xc != yc))
			LCD_Pixel(-yc + X, xc + Y);
		
		if (d < 0)
		{
			d = d + 4 * xc + 6;
		}
		else
		{
			d = d + 4 * (xc - yc) + 10;
			yc--;
		}
		xc++;
	};
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Рисование прямоугольника.
// Параметры:
// X1 - Координата верхнего левого угла прямоугольника по горизонтали (0..121),
// Y1 - Координата верхнего левого угла прямоугольника по вертикали (0..31),
// X2 - Координата нижнего правого угла прямоугольника по горизонтали (0..121),
// Y1 - Координата нижнего правого угла прямоугольника по вертикали (0...31),
// Fill - Флаг устанавливается, если нужно, чтобы внутренняя область
//        прямоугольника была закрашена.
///////////////////////////////////////////////////////////////////////////////
void LCD_Rect(uint8_t X1, uint8_t Y1, uint8_t X2, uint8_t Y2, uint8_t Fill)
{
	#if defined(LCD_USE_RAM_BUF)
	union Union32 mask;
	uint8_t sizeY;
	uint8_t cntByteChangeCol;
	uint8_t x, num;
	uint8_t data;
	#if defined(LCD_ROTATE)
	uint8_t y;
	#endif	
	#endif

	// Разбираемся со входными параметрами
	
	// Если левая координата больше правой, то меняем их значения между собой
	if (X1 > X2) SWAP(X1, X2)
	
	// Если верхняя координата больше нижней, то меняем их значения между собой
	if (Y1 > Y2) SWAP(Y1, Y2)

	#if defined(LCD_USE_RAM_BUF)
	if (Fill)
	{
		if ((X1 >= LCD_X_RES) || (Y1 >= LCD_Y_RES)) return;
		if (X2 >= LCD_X_RES) X2 = LCD_X_RES - 1;
		if (Y2 >= LCD_Y_RES) Y2 = LCD_Y_RES - 1;
		X2++;
		Y2++;

		// Вычисляем новые координаты для изменяемой области буфера
		xlChanged = Min(X1, xlChanged);
		xhChanged = Max(X2, xhChanged);
		ylChanged = Min(Y1, ylChanged);
		yhChanged = Max(Y2, yhChanged);

		// Вычисляем размер прямоугольника по вертикали
		sizeY = Y2 - Y1;
	
		// Вычисляем маску, которую будем использовать для отображения
		// прямоугольника.
		// В этой маске количество единиц равно высоте прямоугольника.
		mask.value = 1;
		mask.value <<= sizeY;
		mask.value--; // Получаем маску в виде всех единиц для значимых
						// точек столбцов прямоугольника
		#if defined(LCD_ROTATE)
		// Получаем маску, сдвинутую к старшим разрядам
		mask.value <<= sizeof(mask) * 8 - sizeY - Y1 % 8;
		#else
		mask.value <<= Y1 % 8;
		#endif

		// Подсчитываем количество байт для одного столбца прямоугольника,
		// которые будут подвергнуты изменению.

		cntByteChangeCol = 0;

		#if defined(LCD_ROTATE)
		for (num = sizeof(mask); num > 0; num--)
		{
			if (mask.byte[num - 1] != 0) cntByteChangeCol++;
			else break;
		}
		#else
		for (num = 0; num < sizeof(mask); num++)
		{
			if (mask.byte[num] != 0) cntByteChangeCol++;
			else break;
		}
		#endif
	
		if (DrawMode == LCD_AND) mask.value = ~mask.value;

		// Цикл по каждому столбцу прямоугольника
		for (x = X1; x < X2; x++)
		{
			for (num = 0; num < cntByteChangeCol; num++)
			{
				#if defined(LCD_ROTATE)
				y = ((LCD_Y_RES - 1) - (Y1 + num * 8)) / 8;
				data = Buf[y][(LCD_X_RES - 1) - x];
				if (DrawMode == LCD_OR) data |=
					mask.byte[(sizeof(mask) - 1) - num];
				else if (DrawMode == LCD_XOR) data ^=
					mask.byte[(sizeof(mask)) - 1 - num];
				else if (DrawMode == LCD_AND)data &=
					mask.byte[(sizeof(mask) - 1) - num];
				Buf[y][(LCD_X_RES - 1) - x] = data;
				#else
				data = Buf[(Y1 + num * 8) / 8][x];
				if (DrawMode == LCD_OR) data |= mask.byte[num];
				else if (DrawMode == LCD_XOR) data ^= mask.byte[num];
				else if (DrawMode == LCD_AND) data &= mask.byte[num];
				Buf[(Y1 + num * 8) / 8][x] = data;
				#endif
			}
		}
		
		// Вывод измененной области буфера в индикатор
		LCD_Update();
	}
	#else
	if (0) {;}
	#endif

	else
	{
		LCD_Line(X1, Y1, X2, Y1);
		if (Y2 > Y1)
			LCD_Line(X1, Y2, X2, Y2);

		if ((Y2 - Y1) > 1)
			LCD_Line(X1, (Y1 + 1), X1, (Y2 - 1));

		if ((X2 > X1) && ((Y2 - Y1) > 1))
			LCD_Line(X2, (Y1 + 1), X2, (Y2 - 1));

		#if !defined(LCD_USE_RAM_BUF)
		if (Fill)
		{
			if ((Y2 - Y1) > 1)
			{
				while ((X2 - X1) > 1)
				{
					X1++;
					LCD_Line(X1, (Y1 + 1), X1, (Y2 - 1));
				}
			}
		}
		#endif
	}
}
///////////////////////////////////////////////////////////////////////////////
